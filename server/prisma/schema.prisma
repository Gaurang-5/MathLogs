generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Institute {
  id            String         @id @default(uuid())
  name          String
  createdAt     DateTime       @default(now())

  updatedAt     DateTime       @updatedAt
  
  // Contact Details
  teacherName   String?
  phoneNumber   String?
  email         String?
  config        Json?          @default("{\"requiresGrades\": true, \"allowedClasses\": [\"9\", \"10\"], \"subjects\": [\"Math\", \"Science\"]}")
  plan          Tier           @default(FREE)
  
  // Status
  status           String      @default("ACTIVE") // ACTIVE, SUSPENDED
  suspensionReason String?

  admins        Admin[]
  academicYears AcademicYear[]
  students      Student[]
  batches       Batch[]
  tests         Test[]
  invites       InviteToken[]
}

model InviteToken {
  id          String    @id @default(uuid())
  token       String    @unique
  instituteId String
  institute   Institute @relation(fields: [instituteId], references: [id])
  isUsed      Boolean   @default(false)
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
}

model Admin {
  id                  String  @id @default(uuid())
  username            String  @unique
  password            String
  passwordVersion     Int     @default(1)  // Increment on password change to invalidate old JWTs
  currentAcademicYear String  @default("2024-2025")
  
  // Multi-tenancy
  role                String  @default("INSTITUTE_ADMIN") // SUPER_ADMIN, INSTITUTE_ADMIN, STAFF
  instituteId         String? // Optional during migration
  institute           Institute? @relation(fields: [instituteId], references: [id])
  
  // New Academic Year Logic
  currentAcademicYearId String?
  activeAcademicYear    AcademicYear? @relation("ActiveYear", fields: [currentAcademicYearId], references: [id])
  
  ownedAcademicYears    AcademicYear[] @relation("OwnedYears")

  batches             Batch[]
  tests               Test[]
}

model AcademicYear {
  id        String   @id @default(uuid())
  name      String
  startDate DateTime?
  endDate   DateTime?
  isDefault Boolean  @default(false)
  
  instituteId String? // Optional during migration
  institute   Institute? @relation(fields: [instituteId], references: [id])
  
  teacherId String
  teacher   Admin    @relation("OwnedYears", fields: [teacherId], references: [id])
  
  activeForAdmins Admin[] @relation("ActiveYear")
  
  batches   Batch[]
  students  Student[]
  tests     Test[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([teacherId, name])
}

model Batch {
  id                  String           @id @default(uuid())
  name                String
  subject             String?
  className           String?
  timeSlot            String?
  feeAmount           Float            @default(0)
  academicYear        String?
  
  academicYearId      String?
  academicYearRef     AcademicYear?    @relation(fields: [academicYearId], references: [id])
  
  instituteId         String? // Optional during migration
  institute           Institute? @relation(fields: [instituteId], references: [id])

  whatsappGroupLink   String?
  isRegistrationOpen  Boolean          @default(true)
  isRegistrationEnded Boolean          @default(false)
  batchNumber         Int?
  teacherId           String?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  teacher             Admin?           @relation(fields: [teacherId], references: [id])
  feeInstallments     FeeInstallment[]
  students            Student[]

  @@index([teacherId, academicYearId, className])  // PERF: Common filter combination
}

model Student {
  id             String       @id @default(uuid())
  humanId        String?
  name           String
  parentName     String
  parentWhatsapp String
  parentEmail    String?
  status         String       @default("PENDING")
  batchId        String?
  
  academicYearId String?
  academicYearRef AcademicYear? @relation(fields: [academicYearId], references: [id])

  instituteId    String? // Optional during migration
  institute      Institute? @relation(fields: [instituteId], references: [id])

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  schoolName     String?
  feePayments    FeePayment[]
  fees           FeeRecord[]
  marks          Mark[]
  batch          Batch?       @relation(fields: [batchId], references: [id])
  balance        StudentBalance? // PERF: Materialized balance (auto-updated by DB triggers)

  @@index([batchId])
  @@index([status])
  @@index([name])
  @@index([status, academicYearId])  // PERF: For approved student listings
  @@index([batchId, status])          // PERF: For batch details queries
  @@index([createdAt])                // PERF: For growth stats chronological queries
  @@unique([humanId, academicYearId])
  @@unique([name, parentWhatsapp, batchId], name: "student_natural_key")
}

model FeeRecord {
  id        String   @id @default(uuid())
  amount    Float
  date      DateTime @default(now())
  status    String   @default("PAID")
  studentId String
  student   Student  @relation(fields: [studentId], references: [id])

  @@index([studentId])
  @@index([date])  // PERF: For recent transactions and chronological queries
}

model Test {
  id           String   @id @default(uuid())
  name         String
  subject      String
  className    String?
  date         DateTime
  maxMarks     Float
  
  instituteId  String? // Optional during migration
  institute    Institute? @relation(fields: [instituteId], references: [id])

  teacherId    String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  academicYear String?
  
  academicYearId String?
  academicYearRef AcademicYear? @relation(fields: [academicYearId], references: [id])

  marks        Mark[]
  teacher      Admin?   @relation(fields: [teacherId], references: [id])

  @@index([teacherId, academicYearId])  // PERF: For teacher test lookups
  @@index([date])                       // PERF: For chronological test lists
}

model Mark {
  id        String  @id @default(uuid())
  score     Float
  studentId String
  testId    String
  test      Test    @relation(fields: [testId], references: [id], onDelete: Cascade)
  student   Student @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([studentId, testId])
  @@index([testId])
  @@index([studentId])
}

model FeeInstallment {
  id        String       @id @default(uuid())
  name      String
  amount    Float
  batchId   String
  createdAt DateTime     @default(now())
  batch     Batch        @relation(fields: [batchId], references: [id], onDelete: Cascade)
  payments  FeePayment[]

  @@index([batchId])
}

model FeePayment {
  id            String         @id @default(uuid())
  date          DateTime       @default(now())
  amountPaid    Float
  studentId     String
  installmentId String
  createdAt     DateTime       @default(now())
  installment   FeeInstallment @relation(fields: [installmentId], references: [id], onDelete: Cascade)
  student       Student        @relation(fields: [studentId], references: [id], onDelete: Cascade)

  // Removed @@unique([studentId, installmentId]) to allow multiple partial payments
  @@index([studentId])
  @@index([installmentId])
  @@index([studentId, installmentId]) // Added for query performance
  @@index([date]) // PERF: For dashboard monthly collection queries
}

// PERF: Materialized view for student balances
// Auto-updated via database triggers when fees/payments change
// Eliminates duplicate balance calculations across endpoints
model StudentBalance {
  studentId       String    @id
  totalFee        Float     @default(0)
  totalPaid       Float     @default(0)
  balance         Float     @default(0)
  lastPaymentDate DateTime?
  updatedAt       DateTime  @default(now())
  
  student Student @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@index([balance], name: "idx_balance_desc") // For finding defaulters
  @@index([updatedAt]) // For recent updates
}

model IdCounter {
  prefix String @id
  seq    Int
}

enum Tier {
  FREE
  PRO
  ENTERPRISE
}

model EmailJob {
  id          String    @id @default(uuid())
  recipient   String
  subject     String
  body        String
  status      JobStatus @default(PENDING)
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  error       String?
  options     Json?     // Stores { senderName, replyTo, senderType }
  
  instituteId String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status])
  @@index([createdAt]) // FIFO processing
}

model WhatsappJob {
  id          String    @id @default(uuid())
  recipient   String    // Phone number (E.164 format: +91...)
  templateId  String    // e.g., "fee_reminder"
  data        Json      // Variables: ["Rahul", "5000"]
  status      JobStatus @default(PENDING) // PENDING, PROCESSING, COMPLETED, FAILED
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  error       String?
  messageId   String?   // External ID from provider
  
  instituteId String?   // For usage tracking/billing per institute
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status])
  @@index([createdAt])
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
